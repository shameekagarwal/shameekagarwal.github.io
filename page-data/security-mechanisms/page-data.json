{"componentChunkName":"component---src-templates-blog-js","path":"/security-mechanisms/","result":{"data":{"markdownRemark":{"fields":{"slug":"/security-mechanisms/"},"id":"a6152d76-26b7-5e44-9f9f-edf9cf83d565","html":"<h1 id=\"jwt\" style=\"position:relative;\"><a href=\"#jwt\" aria-label=\"jwt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT</h1>\n<ul>\n<li>jwt stands for json web tokens</li>\n<li>a specification called rfc 7519 outlines how a jwt should be structured</li>\n<li>http is meant to be a stateless protocol, so no state is maintained across requests</li>\n<li>how session tokens work - a session is created for each user on the server side. this session is associated with a session id. clients receive this session id, and the browser typically stores it in a cookie. now, the cookie is forwarded along with every request to the server</li>\n<li>issue: it assumes one server, and a session used to be typically associated with one server. but as applications grew, we had proxies and load balancers routing requests to different servers</li>\n<li>solution one: shared session, e.g. redis. disadvantages: single point of failure, latency due to lookup</li>\n<li>solution two: sticky sessions in case of load balancing i.e. remember which server to forward the request to. disadvantages: will only work if there are multiple instances of the same server, not for microservices</li>\n<li>in jwt, all required information is stored as a part of the token itself, the need of a data store is removed now</li>\n<li>clients should add the token to all future requests</li>\n<li>the different services just need to have the ability to parse and verify the token</li>\n<li>a jwt has three parts separated by a period - header, payload and signature</li>\n<li>the payload is just a base64 encoded version of the information we want to add to the token</li>\n<li>the header too is just a base64 encoded version of the algorithm used for signing the token</li>\n<li>since the header and the payload are exposed, we should never add secret information like passwords to them</li>\n<li>the signature is created by signing the header and the payload and using a secret</li>\n<li>the secret should never be disclosed, otherwise anyone can generate the tokens</li>\n<li>we can use the tools <a href=\"https://www.base64decode.org\">base64decode</a> and <a href=\"https://jwt.io\">jwt.io</a> to experiment</li>\n<li>jwt is used for authorization, not authentication. a jwt is generated after authentication</li>\n<li>disadvantage: anyone can take our token and impersonate as us, solution is to use practices like https</li>\n<li>in jwt we can have an expiration time which would require to regenerate jwt after some time</li>\n<li>to handle compromising of jwt, we can maintain a blacklisted list of jwts on the server</li>\n</ul>\n<p>following is an example of how hs256 works, hs256 = hmac + sha256</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> encodedHeader     <span class=\"token operator\">=</span> <span class=\"token function\">base64</span><span class=\"token punctuation\">(</span><span class=\"token function\">utf8</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>header<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> encodedPayload    <span class=\"token operator\">=</span> <span class=\"token function\">base64</span><span class=\"token punctuation\">(</span><span class=\"token function\">utf8</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> signature         <span class=\"token operator\">=</span> <span class=\"token function\">base64</span><span class=\"token punctuation\">(</span><span class=\"token function\">hmac</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>encodedHeader<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>encodedPayload<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> secret<span class=\"token punctuation\">,</span> sha256<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> jwt               <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>encodedHeader<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>encodedPayload<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>signature<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id=\"oauth\" style=\"position:relative;\"><a href=\"#oauth\" aria-label=\"oauth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OAuth</h1>\n<ul>\n<li>the point here is that we do not provide our username and password of the authorization server to the client for it to be able access resources on the resource server</li>\n<li>resource or protected resource - e.g. photos</li>\n<li>resource owner - the person owning the resource</li>\n<li>resource server - the server holding the protected resource</li>\n<li>client - the server requesting access for the protected resource</li>\n<li>authorization server - authorizes client to access resource server</li>\n<li>sometimes, the authorization server and resource server can be clubbed into one</li>\n<li>redirect uri - authorization server redirects the resource owner to this url after granting permission to the client. it is also called the callback url</li>\n<li>scopes - the list of actions the client would like to perform</li>\n<li>client id and client secret - helps authenticate the client with the authorization server</li>\n<li>authorization code flow\n<ul>\n<li>the resource owner asks the client to perform some action using the resource server</li>\n<li>the client redirects the resource owner to the authorization server, and includes the client id, redirect uri and scopes as a part of this request</li>\n<li>the authorization server then shows the name of the client itself, the list of resources the client is trying to access, etc. to the resource owner</li>\n<li>the resource owner then gives permission to the authorization server</li>\n<li>on getting this permission, the authorization server gives the client an authorization token by redirecting to the redirect uri which was provided at the time of request</li>\n<li>the client goes back to the authorization server to get the access token, by providing the client id, the client secret and the authorization code from the previous exchange during this. this step is abstracted away from the resource owner themselves usually, and happens behind the scenes</li>\n<li>the client can now use this access token and reach out to the resource server</li>\n<li>the resource server then validates this token, and it can or cannot use the authorization server for this. based on the status of this validation, it grants the client access to its resource</li>\n</ul>\n</li>\n<li>implicit flow - the same as authorization code flow except that instead of exchanging authorization token to get the access token, the client gets the access token directly</li>\n<li>client credentials flow - there is no concept of resource owner. the client is considered very trustworthy. it directly asks the authorization server for the access token, it then and uses this token to access resources on the resource server. this flow can be used when resource server and client are both microservices owned by us</li>\n<li>openid connect (oidc) is for authentication, oauth 2.0 for authorization</li>\n<li>when an authorization server supports oidc, it is often called an idp (identity provider)</li>\n<li>oidc supports using one login across multiple apps, and this feature is called sso (single sign on)</li>\n<li>the idea is that when requesting for authorization code, in the list of scopes, the client should add the additional scope of openid. this way, along with the access token, the authorization server also sends an id token which contains some non-secret information about the user. and this is jwt 🥵</li>\n</ul>","frontmatter":{"title":"Security Mechanisms"}}},"pageContext":{"id":"a6152d76-26b7-5e44-9f9f-edf9cf83d565"}},"staticQueryHashes":["1037383464","1617985380"]}