{"componentChunkName":"component---src-templates-blog-js","path":"/multithreading-in-java/","result":{"data":{"markdownRemark":{"fields":{"slug":"/multithreading-in-java/"},"id":"3361a22c-3d84-58f0-8635-886135d79b81","html":"<ul>\n<li>there are two benefits of multithreading - responsiveness and performance</li>\n<li>concurrency means performing different tasks on the same core. instead of waiting for one task to entirely complete first, we perform both simultaneously in a time-shared manner. it increases responsiveness</li>\n<li>parallelism means performing different tasks on different cores. it increases performance</li>\n<li>throughput is the number of tasks completed per unit time, while latency is the time taken per unit task</li>\n<li>when we execute a program, it becomes a process i.e. it gets loaded into the memory from the disk and a thread is used to execute it</li>\n<li>there are often way more processes being executed than cores in a cpu. so using context switching, one thread at a time gets cpu and, gets paused and another thread is scheduled on the cpu</li>\n<li>context switching has overhead, and doing a lot of it can lead to something called thrashing</li>\n<li>however, context switching between the threads of the same process is much cheaper than context switching between the threads of different processes, since a lot of components like heaps are reused</li>\n<li>there are various algorithms used by the operating system to calculate the priority of a task. we can also programmatically provide a priority which gets used in the calculation. this determines what thread gets executed at a particular instant</li>\n<li>modern day computers use hyper threading i.e. the same physical core is divided into multiple virtual cores</li>\n<li>a thing that struck me - when writing applications, do not base your conclusions off the computer you are running your code on, base it off how it would work on the server</li>\n<li>thread pooling - reusing threads instead of recreating them</li>\n<li>we create an instance of <code class=\"language-text\">Thread</code> and to it, we pass an object of a class that implements <code class=\"language-text\">Runnable</code>. its <code class=\"language-text\">run</code> method needs to be overridden. all of this can be replaced by a lambda\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Thread</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"i am inside \"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>when we run <code class=\"language-text\">Thread.sleep</code>, we instruct the os to not schedule that thread until the timeout is over. invoking this method does not consume any cpu i.e. it is not like a while loop that waits for 5 seconds</li>\n<li>we can set a name of a thread to make it helpful when debugging, using <code class=\"language-text\">thread.setName()</code></li>\n<li>we can set a priority between 1 and 10 using <code class=\"language-text\">thread.setPriority</code></li>\n<li>we can use <code class=\"language-text\">thread.setUncaughtExceptionHandler</code> to catch exceptions that might have occurred during the execution of the thread, and cleanup resources</li>\n<li>if instead of using <code class=\"language-text\">Runnable</code>, we extend the <code class=\"language-text\">Thread</code> class, we get access to a lot of internal methods</li>\n<li>we can shut down the application entirely from any thread using <code class=\"language-text\">System.exit(0)</code></li>\n<li>the application will not terminate until all threads stop</li>\n<li>but, we might want to interrupt a thread so that the thread can maybe understand that the application wants to terminate, and accordingly handle cleaning up of resources\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Thread</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>the interruption can be handled gracefully in two ways as described below</li>\n<li>if our code throws an interrupted exception, calling <code class=\"language-text\">interrupt</code> will trigger it, and then we can handle it\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Task</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[inside catch] i was interrupted...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\nother examples where this happens are for calls like <code class=\"language-text\">thread.join()</code> and <code class=\"language-text\">object.wait()</code></li>\n<li>else we can check the property <code class=\"language-text\">isInterrupted</code> and handle it accordingly\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Task</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Date</span> date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[inside loop] i was interrupted...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>if we implement <code class=\"language-text\">Callable</code> instead of <code class=\"language-text\">Runnable</code>, we can also throw an <code class=\"language-text\">InterruptedException</code> when for e.g. we see that <code class=\"language-text\">isInterrupted</code> is evaluated to true. this means the parent thread calling this thread will know that it was interrupted in an adhoc manner</li>\n<li>there might be a case when what the thread does need not be handled gracefully, and it is just an overhead for us to check for e.g. the <code class=\"language-text\">isInterrupted</code> continually. so, we can set the daemon property of the thread to true. this way when the thread is interrupted, it will be terminated without us having to handle it\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Thread</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">setDaemon</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>threads execute independent of each other. but what if thread b depends on the results of thread a?</li>\n<li>one way could be we run a loop in thread b to monitor the status of thread a (assume thread a sets a boolean to true). this means thread b is also using resources, which is not ideal</li>\n<li>so, if we call <code class=\"language-text\">threadA.join()</code> from thread b, thread b goes into waiting state till thread a completes. we should also consider calling the join with a timeout, e.g. <code class=\"language-text\">threadA.join(t)</code></li>\n<li>in case of multithreading, components like heaps get shared across the threads, while components like stack and instruction pointer are scoped to a thread</li>\n<li>a stack is used for local variables of a method call, and is used alongside instruction pointer. a frame is created for every method call, and it can result with a stackoverflow exception if we end up with too many frames. a stack and instruction pointer are scoped to a thread</li>\n<li>heap belongs to a process, and all threads can write to / read from the heap at any given time. all objects are stored in the heap till there is a reference to them, after which they get garbage collected</li>\n<li>we can wrap our code blocks with a critical section, which makes them atomic. this way, only one thread can access that block of code at a time, and any other thread trying to access it during this will be suspended till the critical section is freed</li>\n<li>say we use <code class=\"language-text\">synchronized</code> on multiple methods of a class. once a thread invokes one of the methods of this class, no other thread can invoke any other method of this class. this is because using synchronized on a method is applied on the instance (object)</li>\n<li>the object referred to above is called a monitor. only one thread can acquire a monitor at a time\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>another method is to use synchronized blocks. this way, the code is much more flexible since we can have different critical sections locked on different monitors\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>so, assignment to references and primitive values in java are atomic. however, an exception in this is assignment to longs and doubles. since it is 64bit, it happens in 2 operations - one assignment for the lower 32 bit and another one for the upper 32 bit. the solution is to declare them with volatile, e.g. <code class=\"language-text\">volatile double a = 1.2</code>. using volatile makes operations on longs and doubles atomic. java also has a lot of atomic classes under <code class=\"language-text\">java.util.concurrent.atomic</code></li>\n<li>race condition is a generic term, it happens when some critical section is processed concurrently by multiple threads, and we wouldn’t want that for some sections of our code</li>\n<li>data race - when the order of operations on variables do not match the sequential code we write. this happens mostly because there are optimizations like prefetching, vectorization, rearranging of instructions, etc\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Pair</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    b<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">></span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"well that doesn't seem right...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\ncalling the class -\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Pair</span> pair <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Pair</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> pair<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> pair<span class=\"token punctuation\">.</span><span class=\"token function\">check</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nt1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nt1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> t2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>our expectation is that since b is read before a and a is incremented before b, there is no way even with a race condition that b can be bigger than a. however, due to data race, we do hit the print statement. this is also where we can use <code class=\"language-text\">volatile</code>. volatile guarantees the order of instructions being executed\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n</li>\n<li>this is called the visibility problem</li>\n<li>basically, the two threads have their own local version of cache, but also have a shared cache. they write the value to the local cache, but this does not\n<ul>\n<li>either update the shared cache</li>\n<li>or the second thread’s local cache does not refresh its value from the shared cache</li>\n</ul>\n</li>\n<li>however, when we use volatile, it refreshes both the shared cache and the local cache of all threads</li>\n<li>basically, code before access to a volatile variable gets executed before it, and code after the access to a volatile variable after. this is called the happens before relationship</li>\n<li>while we could have just used synchronized for both the methods above, realize the advantage of using volatile over synchronized. with synchronization, we lose out on the multithreading, since our functions would have been invoked one at a time. in this case, the two methods are still being invoked concurrently</li>\n<li>if we have n cores, for each core we have a register. then we have an associated l1 cache on top of each register. l2 cache can be shared across multiple cores, and finally we have only one l3 cache and ram\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 451px; margin: 5px 0 5px 0 !important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/97bf27a6c1f55c291fdbf427cfa8cd9d/38070/multithreading.drawio.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.55696202531645%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXklEQVQ4y4WT6Y6DMAyE8/6Px09AFQhoy1UQLT04mtU3K0usBFokE2c8sZ1J4qIo8kVRyPI892ma+iRJ5INlWab5HgYXzIxc7na7eb7H46Hx+Xz6vu//YPf7XbbF4MDlG8dRI7lc27aaXK9XvyyLgl3X+XVdhX2/Xz8Mg2yeZ2F8cOC+329flqWwpmm8u1wuAj+fj0YK1HUtf5omjRAxw16vlzhwWYeBkcudz2dpEQSBj+NY1ejidDoJYzSMOBj6MQcPw1AYuqKv40cAgAq2GB/MFmJbzHAaAquq6jchDjqZbmiFuPhgxDgADI3twNiu6WoYuRzZCVIRXaw6mtlIZxhxujIM39aQg1zqkG4Qmw7sRPHBiFmHW56d8panDrmQbJGqVNkzOoF8FGctBcilLVOdpHtGzLb3H09bhsj9ov094zVYQvwjnl1wXWwAdLMnZgbGU+NqwMM/4pGDi/0DY5vYoH6puywAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"multithreading\"\n        title=\"multithreading\"\n        src=\"/static/97bf27a6c1f55c291fdbf427cfa8cd9d/38070/multithreading.drawio.png\"\n        srcset=\"/static/97bf27a6c1f55c291fdbf427cfa8cd9d/c26ae/multithreading.drawio.png 158w,\n/static/97bf27a6c1f55c291fdbf427cfa8cd9d/6bdcf/multithreading.drawio.png 315w,\n/static/97bf27a6c1f55c291fdbf427cfa8cd9d/38070/multithreading.drawio.png 451w\"\n        sizes=\"(max-width: 451px) 100vw, 451px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></li>\n<li>java memory model - it is an enforcement that jvm implementations have to follow so that java programs have similar behavior everywhere, and the different optimizations of instructions, cache, etc. do not affect the functioning of the program</li>\n<li>coarse-grained locking - meaning we use one lock for everything, just like having synchronized on all methods, not performant. its counterpart is fine-grained locking</li>\n<li>however with fine-grained locking, we can run into deadlocks more often</li>\n<li>conditions for a deadlock -\n<ul>\n<li>mutual exclusion - only one thread can hold the resource at a time</li>\n<li>hold and wait - the thread acquires the resource and is waiting for another resource to be freed up</li>\n<li>non-preemptive - the resource is released only when the thread is done using it and another thread cannot acquire it forcefully</li>\n<li>circular wait - a cyclic dependency is formed where threads wait for resources acquired by each other</li>\n</ul>\n</li>\n<li>one way to prevent deadlocks is to acquire locks in our code in the same order. this need not be considered when releasing the locks</li>\n<li>reentrant lock - instead of having a synchronized block, we use this reentrant lock\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Lock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>to avoid deadlocks caused by for e.g. the method throwing exceptions, we should use it in the following way -\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\">lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// critical section</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n  lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>it provides a lot of methods for more advanced use cases like <code class=\"language-text\">getOwner</code>, <code class=\"language-text\">getQueuedThreads</code>, <code class=\"language-text\">isHeldByCurrentThread</code>, <code class=\"language-text\">isLocked</code>, etc</li>\n<li>the name <code class=\"language-text\">Reentrant</code> comes from the fact that the lock can be acquired by the thread multiple times, which means it would have to free it multiple times as well, e.g. think about recursive calls. we can get the number of times it was acquired using <code class=\"language-text\">getHoldCount</code></li>\n<li>another benefit of using reentrant locks is fairness - e.g. what if a thread repeatedly acquires the lock, leading to the starving of other threads? we can prevent this by instantiating it using <code class=\"language-text\">new ReentrantLock(true)</code></li>\n<li>note that introducing fairness also has some overhead associated with it, thus impacting performance</li>\n<li>if we do not set to true, what we get is a barge in lock i.e. suppose there are three threads waiting for the lock in a queue. when the thread originally with the lock releases it, if a new thread not in the queue comes up to acquire the lock, it gets the lock and the threads in the queue continue to stay there. however, if we had set the fairness to true, the thread with the longest waiting time gets it first</li>\n<li>if the lock is not available, the thread ofcourse goes into the suspended state till it is able to acquire the lock. we can prevent this using <code class=\"language-text\">lockInterruptibily</code>, so that an exception is thrown instead which helps the thread to continue with its execution\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibily</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// cleanup and exit</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>similar to above, we also have the <code class=\"language-text\">tryLock</code> method, which returns a boolean that indicates whether a lock was successfully acquired. it also accepts timeout as a parameter, &#x26; what it does is self-explanatory. this can help, for e.g. in realtime applications to provide feedback continuously without pausing the application entirely\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">tryLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// critical section</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n      lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// some logic  </span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// some logic</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>multiple readers can access a resource concurrently but multiple writers or one writer with multiple readers cannot. this is why we have <code class=\"language-text\">ReentrantReadWriteLock</code>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">ReentrantReadWriteLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantReadWriteLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Lock</span> readLock <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">readLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Lock</span> writeLock <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">writeLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>fairness in <code class=\"language-text\">ReentrantReadWriteLock</code> works the same way as <code class=\"language-text\">ReentrantLock</code>, except that if the thread waiting for the longest time was a reader, all reader threads in the queue are freed up to read</li>\n<li>semaphore - it helps restrict number of users to a resource. a user can also acquire multiple resources</li>\n<li>the thread is blocked till a resource in the semaphore is released</li>\n<li>a lock is like a semaphore with one resource, but the major difference is that a semaphore acquired by thread a can be released by thread b, so that thread a can acquire it again without having ever released it</li>\n<li>semaphores are a great choice for producer consumer problems</li>\n<li>condition - conditions are always associated with a lock</li>\n<li>when we wait on a condition, the thread releases the lock and goes to sleep</li>\n<li>when another thread runs <code class=\"language-text\">signal</code> on the condition, the threads waiting for the condition wake up</li>\n<li>placing the condition inside the while loop helps so that even if signalled, it will again start waiting if the condition is not met yet</li>\n<li>we always wrap this entire functionality with a lock, so that, for e.g. the checking of condition x is atomic and the variables used in it cannot be modified by multiple threads</li>\n<li>so, even though the thread which was waiting gets signaled to wake up, it also needs to be able to acquire the lock again, i.e. the other threads modifying state need to release the lock\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">ReentrantLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Condition</span> condition <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\n\nlock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>condition x is not met<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    condition<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n  lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ...</span>\n\nlock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// modify variables used in condition x...</span>\n  condition<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n  lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>conditions also have advanced methods like <code class=\"language-text\">await(timeout)</code>, <code class=\"language-text\">signalAll</code>, etc</li>\n<li>the class Object, and therefore all objects have methods <code class=\"language-text\">wait</code>, <code class=\"language-text\">notify</code> and <code class=\"language-text\">notifyAll</code></li>\n<li>when we call <code class=\"language-text\">wait</code> on an object, the thread it was called on continues to be in waiting state until another thread calls <code class=\"language-text\">notify</code> on that object</li>\n<li><code class=\"language-text\">notify</code> will wake up any random thread that was sleeping, and to wake up all threads we can use <code class=\"language-text\">notifyAll</code></li>\n<li>if we think about it, the <code class=\"language-text\">lock.lock()</code> and <code class=\"language-text\">lock.unlock()</code> are the starting and ending of <code class=\"language-text\">synchronize</code> blocks respectively, <code class=\"language-text\">condition.await()</code> is like <code class=\"language-text\">wait()</code> and <code class=\"language-text\">condition.signal()</code> like <code class=\"language-text\">notify()</code></li>\n<li>introducing locks can make our code more error-prone, more subject to deadlocks etc. however, it makes the code more flexible, e.g. unlike synchronized blocks which have to exist within a single method, locks can be acquired and freed from different methods</li>\n<li>our main objective is to execute instructions as a single hardware operation</li>\n<li>we can achieve this by using Atomic classes provided by java\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">AtomicInteger</span> count <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncount<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n</li>\n<li>the disadvantage of using these classes is ofcourse that only each operation by itself is atomic, a series of such calls together is not atomic, so it may be good only for simpler use cases</li>\n<li>a lot of operations use <code class=\"language-text\">compareAndSet</code> underneath, and we have access to it to. it sets the value to the new value if the current value does not match the expected value. it also returns a boolean which is true if the current value matches the expected value\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\">count<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>expectedValue<span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>we often have a lot of tasks but not so many threads. some objects are not thread safe i.e. cannot be used by multiple threads. however, they can be used by multiple tasks being executed on the same thread. coding this ourselves can be tough, which is why we have <code class=\"language-text\">ThreadLocal</code>, which basically returns a new instance for every thread, and reuses that instance when a thread asks for that instance again\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Car</span><span class=\"token punctuation\">></span></span> car <span class=\"token operator\">=</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token punctuation\">.</span><span class=\"token function\">withInitial</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Car</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>spring uses the concept of this via <code class=\"language-text\">ContextHolder</code>s in for instance, <code class=\"language-text\">RequestContextHolder</code>, <code class=\"language-text\">TransactionContextHolder</code>, <code class=\"language-text\">SecurityContextHolder</code>, etc. my understanding - since spring follows one thread per-request model, this way, any of the services, classes, etc. that need access to information can get it easily. it is like setting and sharing state for a request</li>\n<li>creating threads can be expensive, since each thread in java corresponds to an os thread. my understanding - that means only one java thread can be run at a time on a core?</li>\n<li>my wrong assumption - it is ideal to have the number of threads = the number of cores. this is because threads go in waiting state when, for e.g. waiting for io response. during this, other threads can be scheduled and take advantage of concurrency</li>\n<li>so, when tasks are cpu intensive, we should have number of threads closer to core size, and when tasks are io intensive, we should have higher number of threads, but remember that too many threads can cause performance issues as well due to context switching</li>\n<li>java provides 4 kinds of thread pools - <code class=\"language-text\">FixedThreadPool</code>, <code class=\"language-text\">CachedThreadPool</code>, <code class=\"language-text\">ScheduledThreadPool</code> and <code class=\"language-text\">SingleThreadedExecutor</code></li>\n<li>fixed thread pool executor - polls for tasks stored in a queue. there can be many tasks, but a set number of threads which get reused. the queue should be thread safe i.e. blocking\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">int</span> numberOfProcessors <span class=\"token operator\">=</span> <span class=\"token class-name\">Runtime</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRuntime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">availableProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span>numberOfProcessors<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nexecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>cached thread pool executor - it looks at its threads to see if any of them are free, and if it is able to find one, it will schedule this task on the free thread. else, it will spawn a new thread. too many threads is not too big of a problem, thanks to the keep alive timeout discussed later\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>scheduled thread pool executor - it used a delay queue, so that the tasks get picked up by the threads after the specified delay or schedule. this means tasks might have to be reordered, which is done by the queue itself. <code class=\"language-text\">schedule</code> can help trigger the task after a certain delay, <code class=\"language-text\">scheduleAtFixedRate</code> can help trigger it like a cron at regular intervals while <code class=\"language-text\">scheduleAtFixedDelay</code> can help schedule the next task a fixed time period after the previous task was completed\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">ScheduledExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newScheduledThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nexecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi from \"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">5</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>single thread pool executor - like fixed thread pool executor with size of pool as one. the advantage is for e.g. all the tasks will be run in order of creation</li>\n<li>all thread pool executors create new threads if the previous thread is killed for some reason</li>\n<li>there are a variety of parameters that can be added to the executors</li>\n<li>core pool size - minimum number of threads that are always kept in the pool</li>\n<li>max pool size - maximum number of threads that can be present in the thread pool. it has value <code class=\"language-text\">INTEGER.MAX_VALUE</code> by default for cached and scheduled thread pool executor, while the same value as core pool size for fixed and single thread pool executor</li>\n<li>keep alive timeout - the time till an idle thread is kept in the pool, after which it is removed. keep alive is only applicable to cached and scheduled thread pool executors, since in fixed and single thread pool executors, the number of threads do not change</li>\n<li>note that keep alive timeout does not change the core pool threads. this behavior can however be changed using <code class=\"language-text\">allowCoreThreadTimeOut</code></li>\n<li>queue - the different types of executors use different queues based on their requirements. the queues also need to be thread safe. e.g. a fixed and single thread pool executor has a fixed number of threads, so there can potentially be infinite number of tasks that get queued up, because of which it uses a <code class=\"language-text\">LinkedBlockingQueue</code>. cached thread pool spawns number of threads equal to the number of tasks, so it uses a <code class=\"language-text\">SynchronousQueue</code>, which only needs to hold one task. scheduled thread pool uses <code class=\"language-text\">DelayedWorkQueue</code> so that the tasks are returned from the queue only if the condition of cron etc. is met. optionally, we can provide a custom queue, for e.g. <code class=\"language-text\">ArrayBlockingQueue</code> which unlike <code class=\"language-text\">LinkedBlockingQueue</code> is bounded</li>\n<li>rejection handler - assume all threads are occupied and the queue is full. in this case, the thread pool will reject the task that it gets. how it rejects the task is determined using the rejection policy. the different rejection policies are -\n<ul>\n<li>abort - submitting the new task throws <code class=\"language-text\">RejectedExecutionException</code>, which is a runtime exception</li>\n<li>discard - silently discard the incoming task</li>\n<li>discard oldest - discard the oldest task from the queue to add this new task to the queue</li>\n<li>caller runs - requests the caller thread itself to run this task</li>\n</ul>\n</li>\n<li>till now, to obtain an instance of <code class=\"language-text\">ExecutorService</code>, we were using static methods on <code class=\"language-text\">Executors</code>. we can also use <code class=\"language-text\">new ThreadPoolExecutor()</code> and then pass our own core pool size, queue, etc. configuration parameters as the constructor arguments</li>\n<li>we need to shut down the executor in a clean way. we can initiate it using <code class=\"language-text\">executorService.shutdown()</code>. this will throw the <code class=\"language-text\">RejectedExecutionException</code> for any new tasks that are submitted to it, but at the same time will complete all the currently executing and queued up tasks</li>\n<li>if we run <code class=\"language-text\">shutdownNow</code>, it will return <code class=\"language-text\">List&lt;Runnable></code> for the queued up tasks and clear the queue, but complete all the currently executing tasks</li>\n<li><code class=\"language-text\">awaitTermination(timeout)</code> will terminate the tasks if they are not completed by the specified time</li>\n<li>we also have helper methods like <code class=\"language-text\">isShutdown()</code> and <code class=\"language-text\">isTerminated()</code></li>\n<li>if a task wants to return a value, we use <code class=\"language-text\">Callable</code> instead of <code class=\"language-text\">Runnable</code></li>\n<li>however, the <code class=\"language-text\">execute</code> method on <code class=\"language-text\">ExecutorService</code> only works if we implement <code class=\"language-text\">Runnable</code> interface. if we implement <code class=\"language-text\">Callable</code> interface, we have to use <code class=\"language-text\">submit</code></li>\n<li>the return value of <code class=\"language-text\">Callable</code> is wrapped around a <code class=\"language-text\">Future</code>. <code class=\"language-text\">future.get()</code> is a blocking call i.e. the thread calling it will not move ahead until the future resolves. so, we can also use <code class=\"language-text\">future.get(timeout)</code>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> result <span class=\"token operator\">=</span> executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">4000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// this simulates that we were able to perform 3 seconds worth of operations</span>\n<span class=\"token comment\">// in the main thread while the task thread was performing its blocking stuff</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"result = \"</span> <span class=\"token operator\">+</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>we can cancel the task using <code class=\"language-text\">future.cancel(false)</code>. this means that the thread pool will remove the task from the queue. the false means that if a thread is already running the task, it will not do anything. had we passed true, it would have tried to interrupt the task</li>\n<li>we also have helper methods like <code class=\"language-text\">future.isDone()</code> and <code class=\"language-text\">future.isCancelled()</code></li>\n<li>suppose we have a list of items, and for each item, we want to perform a series of processing\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Package</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">package</span>$ <span class=\"token operator\">=</span> executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">pack</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Delivery</span><span class=\"token punctuation\">></span></span> delivery$ <span class=\"token operator\">=</span> executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">deliver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">package</span>$<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Email</span><span class=\"token punctuation\">></span></span> email$ <span class=\"token operator\">=</span> executorsubmit<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">sendEmail</span><span class=\"token punctuation\">(</span>delivery$<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\nnotice how the calling thread is blocked by all <code class=\"language-text\">get</code> of future. instead, we could use -\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">pack</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">thenApply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">package</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">deliver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">package</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">thenApply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>delivery<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">sendEmail</span><span class=\"token punctuation\">(</span>delivery<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// ...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>in the above case, we have specified a series of steps to run one after another and since we do not care about the results in our main thread, the assigning of tasks to threads is managed by java itself. the main thread is not paused by the get calls. notice how we also do not need to specify any executor</li>\n<li>if we use <code class=\"language-text\">thenApplyAsync</code> instead of <code class=\"language-text\">thenApply</code>, a different thread can be used to execute the next operation instead of the previous one</li>\n<li>internally, <code class=\"language-text\">CompletableFuture</code> uses fork join pool, but we can specify a custom executor as well, e.g. <code class=\"language-text\">thenApplyAsync(fn, executor)</code>. ofcourse we cannot specify an executor for <code class=\"language-text\">thenApply</code> since the thread used for the previous step gets used for it as well</li>\n</ul>","frontmatter":{"title":"Multithreading in Java"}}},"pageContext":{"id":"3361a22c-3d84-58f0-8635-886135d79b81"}},"staticQueryHashes":["1037383464","1617985380"]}