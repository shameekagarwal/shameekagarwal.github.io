{"componentChunkName":"component---src-templates-blog-js","path":"/helm/","result":{"data":{"markdownRemark":{"fields":{"slug":"/helm/"},"id":"42f6cefe-6318-5b41-b7a7-efeb470b75cf","html":"<ul>\n<li>helm is a package manager for kubernetes, like apt is for linux</li>\n<li>this way we don’t have to care about configuration, object types to use, etc</li>\n<li>helm 3 has a lot of breaking changes compared to helm 2, helm 2 used a pod tiller etc</li>\n<li>the public repository for helm is <a href=\"https://artifacthub.io/\">artifacthub</a></li>\n<li>artifacthub supports multiple package managers for kubernetes and isn’t restricted to helm</li>\n<li>installing a helm repository - <code class=\"language-text\">helm repo add bitnami https://charts.bitnami.com/bitnami</code></li>\n<li>the first bitnami in the command above is a label we provide to refer to the repository in future</li>\n<li>installing a chart - <code class=\"language-text\">helm install mysql bitnami/mysql</code>. here, the prefix bitnami comes from the custom label that we provided to refer to the repository</li>\n<li>after running this command, i see a pod, stateful set, services which have been created, with a prefix of <code class=\"language-text\">mysql</code> which comes from the custom label that we provided to refer to the chart</li>\n<li>we can use <code class=\"language-text\">helm list</code> to view the list of the charts, <code class=\"language-text\">helm repo list</code> to view the list of repositories</li>\n<li>to uninstall the chart, we can use <code class=\"language-text\">helm uninstall mysql</code></li>\n<li>why bitnami - currently, there is no official maintainer of helm charts. bitnami is like a vendor which maintains helm charts which we can use</li>\n<li>use <code class=\"language-text\">helm repo update</code> to grab the latest charts from their repositories</li>\n<li><code class=\"language-text\">helm show values prometheus-community/kube-prometheus-stack</code> to see the default values of a chart</li>\n<li>to update running charts, use <code class=\"language-text\">upgrade</code> command, by specifying the label, chart name to use and optionally values. e.g. <code class=\"language-text\">helm upgrade monitoring prometheus-community/kube-prometheus-stack --set=grafana.adminPassword=admin</code>. we can see that the revision number under <code class=\"language-text\">helm list</code> has increased</li>\n<li>instead of providing values in via command line arguments, we can use <code class=\"language-text\">helm upgrade monitoring prometheus-community/kube-prometheus-stack --values=monitoring-values.yml</code></li>\n<li><a href=\"https://martinfowler.com/bliki/SnowflakeServer.html\">snowflake server</a> are servers being modified over time which makes them irreproducible</li>\n<li>the opposite (or ideal) situation is a <a href=\"https://martinfowler.com/bliki/PhoenixServer.html\">phoenix server</a>, which we can easily reproduce</li>\n<li>to avoid snowflake servers when using helm since they can be mutated by maintainers frequently, we should ideally check the helm charts into source control</li>\n<li>so, we can use <code class=\"language-text\">helm pull prometheus-community/kube-prometheus-stack --untar</code>, we see that a folder with the chart name has been created with all the resources</li>\n<li>now, we can specify the local copy in pipelines etc. e.g. <code class=\"language-text\">helm install monitoring ./kube-prometheus-stack</code></li>\n<li>to generate the yaml files from helm, we can use for e.g. <code class=\"language-text\">helm template monitoring ./kube-prometheus-stack/</code> and it would generate the kubernetes manifest without applying it to the cluster. use case - using helm is not allowed. so, we would generate this file somehow and check it into source control\n<ul>\n<li>pro - kubectl will work, no reliance on helm once this file is generated</li>\n<li>con - very large file, cannot maintain as easily e.g. cannot use the <code class=\"language-text\">--values</code> flag</li>\n</ul>\n</li>\n<li>till now, we were using helm to get packaged third party kubernetes resources</li>\n<li>we can also use helm to package our own kubernetes files, as it is more dynamic than yaml</li>\n<li>to generate the bare bones of a project, use <code class=\"language-text\">helm create &lt;&lt;project-name>></code></li>\n<li>Chart.yaml can be left as is for normal use cases</li>\n<li>values.yaml can be used to provide default values which can be overridden using <code class=\"language-text\">--set</code></li>\n<li>all yaml files in templates folder will be converted when we run install, upgrade, etc</li>\n<li>we can run <code class=\"language-text\">helm template .</code> to see the generated templates</li>\n<li>go templating is what is used by helm behind the scenes</li>\n<li>when using functions, we can use the pipe operator. e.g. <code class=\"language-text\">image: {{ .Values.webapp.image | default \"fleetman/webapp\" | lower }}</code>. this means that the <code class=\"language-text\">webapp.image</code> will come from values, if not provided will default to <code class=\"language-text\">fleetman/webapp</code> and finally everything will be converted to lowercase</li>\n<li>using conditionals - suppose we want to suffix our image tags with a <code class=\"language-text\">-dev</code> if the environment is development, else leave it as is. we can use the following -\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">image: {{ .Values.webapp.image }}{{ if .Values.environment | eq \"dev\" }}-dev{{ end }}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>named templates - reusing blocks of yaml repeatedly</li>\n<li>we prefix files with an <code class=\"language-text\">_</code> and suffix with <code class=\"language-text\">.tpl</code></li>\n<li>in helm charts, we can often see <code class=\"language-text\">{{-</code> and not just <code class=\"language-text\">{{</code>, so that there is no blank line in the generated yaml</li>\n<li>template file, following the naming standards e.g. _common.yaml.tpl\n<div class=\"gatsby-highlight\" data-language=\"yaml.tpl\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-yaml.tpl line-numbers\"><code class=\"language-yaml.tpl\">{{ define &quot;webappImage&quot; }}\n- name: webapp\n  image: {{ .Values.webapp.image }}{{ if .Values.environment | eq &quot;dev&quot; }}-dev{{ end }}\n{{ end }}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>the yaml file using these template blocks -\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-yaml line-numbers\"><code class=\"language-yaml\"><span class=\"token comment\"># Deployment definition ...</span>\n      <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">-</span> include \"webappImage\" . <span class=\"token punctuation\">|</span> indent 8 <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li><code class=\"language-text\">template</code> can be used instead of <code class=\"language-text\">include</code>, the indent command won’t work with it though and the proper indentation would have to be ensured in the template file in that case</li>\n<li>in <code class=\"language-text\">include \"webappImage\" .</code>, the <code class=\"language-text\">.</code> signifies the parent of the values, e.g. if we specified <code class=\"language-text\">.Values</code> instead, the template would use <code class=\"language-text\">.webapp.image</code> and <code class=\"language-text\">.environment</code> directly in the snippet above</li>\n<li>note - use <code class=\"language-text\">upgrade</code> if <code class=\"language-text\">install</code> has been used once already</li>\n<li>the charts folder is for child charts, e.g. <code class=\"language-text\">kube-prometheus-stack</code> uses the grafana chart behind the scenes</li>\n<li>if you try to run charts from artifact hub, you will see them prefixed with the label you provide while running <code class=\"language-text\">helm install</code>. this is because they use <code class=\"language-text\">{{ .Release.Name }}</code> in the name</li>\n</ul>","frontmatter":{"title":"Helm"}}},"pageContext":{"id":"42f6cefe-6318-5b41-b7a7-efeb470b75cf"}},"staticQueryHashes":["1037383464","1617985380"]}